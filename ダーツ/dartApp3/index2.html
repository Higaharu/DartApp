<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ダーツ動作再現アプリ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://unpkg.com/ml5@latest/dist/ml5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border-left: 5px solid #3498db;
        }
        h2 {
            color: #3498db;
            margin-top: 0;
        }
        .file-input {
            margin-bottom: 15px;
        }
        .file-input label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .alert {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        .alert-info {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }
        .alert-success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .alert-warning {
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
        }
        .alert-danger {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            height: 400px;
            position: relative;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }
        .progress-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 4px;
            margin: 10px 0;
        }
        .progress-bar {
            height: 20px;
            background-color: #3498db;
            border-radius: 4px;
            width: 0;
            transition: width 0.3s;
            text-align: center;
            color: white;
            line-height: 20px;
        }
        #modelInfo {
            font-size: 14px;
            color: #666;
        }
        .chart-container {
            height: 200px;
            margin: 20px 0;
        }
        .visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        .visualization > div {
            flex: 1;
            min-width: 300px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        #loadingIndicator {
            display: none;
            text-align: center;
            margin: 10px 0;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #3498db;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .file-list {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
            max-height: 150px;
            overflow-y: auto;
        }
        .file-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }
        .file-list-item:last-child {
            border-bottom: none;
        }
        .remove-file {
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 3px 8px;
            cursor: pointer;
            font-size: 12px;
        }
        .remove-file:hover {
            background-color: #c0392b;
        }
        .model-options {
            margin-top: 15px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .form-group {
            margin-bottom: 10px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input[type="number"],
        .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .processing-status {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ダーツ動作再現アプリ</h1>

        <div class="section">
            <h2>1. キャリブレーションデータのアップロード</h2>
            <p>安静時の筋変位データをアップロードしてください。</p>
            <div class="file-input">
                <label for="calibrationFile">キャリブレーションファイル:</label>
                <input type="file" id="calibrationFile" accept=".csv">
            </div>
            <button id="processCalibration">キャリブレーションデータを処理</button>
            <div id="calibrationResult" class="alert alert-info" style="display: none;"></div>
        </div>

        <div class="section">
            <h2>2. トレーニングデータのアップロード</h2>
            <p>筋変位データと腕の角度データを含むトレーニングファイルをアップロードしてください。</p>
            <div class="file-input">
                <label for="trainingFile">トレーニングファイル（複数選択可）:</label>
                <input type="file" id="trainingFile" accept=".csv" multiple>
            </div>
            <div id="trainingFileList" class="file-list" style="display: none;"></div>
            <div class="processing-status" id="processingStatus"></div>
            <button id="processTraining" disabled>トレーニングデータを処理</button>
            <div id="trainingResult" class="alert alert-info" style="display: none;"></div>
        </div>

        <div class="section">
            <h2>3. モデルの構築</h2>
            <p>前処理されたデータを使用してモデルを構築します。</p>
            
            <div class="model-options">
                <h3>モデルオプション</h3>
                <div class="form-group">
                    <label for="epochs">エポック数:</label>
                    <input type="number" id="epochs" min="10" max="500" value="50">
                </div>
                <div class="form-group">
                    <label for="batchSize">バッチサイズ:</label>
                    <input type="number" id="batchSize" min="8" max="128" value="32">
                </div>
                <div class="form-group">
                    <label for="hiddenUnits1">隠れ層1のユニット数:</label>
                    <input type="number" id="hiddenUnits1" min="8" max="64" value="32">
                </div>
                <div class="form-group">
                    <label for="hiddenUnits2">隠れ層2のユニット数:</label>
                    <input type="number" id="hiddenUnits2" min="8" max="64" value="16">
                </div>
                <div class="form-group">
                    <label for="activation">活性化関数:</label>
                    <select id="activation">
                        <option value="relu">ReLU</option>
                        <option value="sigmoid">Sigmoid</option>
                        <option value="tanh">Tanh</option>
                    </select>
                </div>
            </div>
            
            <button id="buildModel" disabled>モデルを構築</button>
            <div id="loadingIndicator">
                <div class="spinner"></div>
                <p>モデル構築中...</p>
            </div>
            <div id="modelResult" class="alert alert-info" style="display: none;"></div>
            <div class="progress-container" id="modelProgressContainer" style="display: none;">
                <div class="progress-bar" id="modelProgressBar">0%</div>
            </div>
            <div id="modelInfo"></div>
        </div>

        <div class="section">
            <h2>4. テストデータのアップロード</h2>
            <p>予測したい筋変位データをアップロードしてください。</p>
            <div class="file-input">
                <label for="testFile">テストファイル:</label>
                <input type="file" id="testFile" accept=".csv">
            </div>
            <button id="processTest" disabled>テストデータを処理</button>
            <div id="testResult" class="alert alert-info" style="display: none;"></div>
        </div>

        <div class="section">
            <h2>5. 動きの再現</h2>
            <p>予測された腕の動きのアニメーション：</p>
            <div class="canvas-container" id="animationContainer"></div>
            <div class="controls">
                <button id="playAnimation" disabled>再生</button>
                <button id="pauseAnimation" disabled>一時停止</button>
                <button id="resetAnimation" disabled>リセット</button>
            </div>
            <div id="angleInfo"></div>
        </div>

        <div class="section">
            <h2>6. データ可視化</h2>
            <div class="visualization">
                <div>
                    <h3>筋変位データグラフ</h3>
                    <div class="chart-container" id="muscleDataChart"></div>
                </div>
                <div>
                    <h3>角度データグラフ</h3>
                    <div class="chart-container" id="angleDataChart"></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // グローバル変数
        let calibrationData = null;
        let trainingFiles = [];
        let processedTrainingData = []; // トレーニングデータは複数ファイルを結合するため、空の配列で初期化
        let testData = null;
        let processedTestData = null;
        let muscleMeans = {};
        let neuralNetwork = null;
        let predictions = [];
        let isPlaying = false;
        let currentFrame = 0;
        let animationFrameId = null;
        let animationSpeed = 50; // ミリ秒単位でのフレーム間の遅延
        let processedFileCount = 0;
        let totalFileCount = 0;

        // キャリブレーションデータとテストデータで期待される列数
        let calibrationExpectedColumns = 16;
        let muscleChannels = Array.from({length: 14}, (_, i) => `Ch.${i}`);
        let angleColumns = ['elbow_angle', 'wrist_angle', 'shoulder_angle'];
        let positionColumns = [
            'hand_x', 'hand_y', 'hand_z',
            'wrist_x', 'wrist_y', 'wrist_z',
            'elbow_x', 'elbow_y', 'elbow_z',
            'shoulder_x', 'shoulder_y', 'shoulder_z'
        ];

        // UI要素
        const calibrationFileInput = document.getElementById('calibrationFile');
        const processCalibrationButton = document.getElementById('processCalibration');
        const calibrationResultDiv = document.getElementById('calibrationResult');

        const trainingFileInput = document.getElementById('trainingFile');
        const trainingFileListDiv = document.getElementById('trainingFileList');
        const processingStatusDiv = document.getElementById('processingStatus');
        const processTrainingButton = document.getElementById('processTraining');
        const trainingResultDiv = document.getElementById('trainingResult');

        const buildModelButton = document.getElementById('buildModel');
        const modelResultDiv = document.getElementById('modelResult');
        const modelInfoDiv = document.getElementById('modelInfo');
        const modelProgressContainer = document.getElementById('modelProgressContainer');
        const modelProgressBar = document.getElementById('modelProgressBar');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const epochsInput = document.getElementById('epochs');
        const batchSizeInput = document.getElementById('batchSize');
        const hiddenUnits1Input = document.getElementById('hiddenUnits1');
        const hiddenUnits2Input = document.getElementById('hiddenUnits2');
        const activationSelect = document.getElementById('activation');

        const testFileInput = document.getElementById('testFile');
        const processTestButton = document.getElementById('processTest');
        const testResultDiv = document.getElementById('testResult');

        const playAnimationButton = document.getElementById('playAnimation');
        const pauseAnimationButton = document.getElementById('pauseAnimation');
        const resetAnimationButton = document.getElementById('resetAnimation');
        const angleInfoDiv = document.getElementById('angleInfo');


        // イベントリスナー
        processCalibrationButton.addEventListener('click', processCalibrationData);
        processTrainingButton.addEventListener('click', processTrainingData);
        buildModelButton.addEventListener('click', buildNeuralNetworkModel);
        processTestButton.addEventListener('click', processTestData);
        playAnimationButton.addEventListener('click', playAnimation);
        pauseAnimationButton.addEventListener('click', pauseAnimation);
        resetAnimationButton.addEventListener('click', resetAnimation);

        // ファイルが選択されたときの処理 (trainingFile)
        trainingFileInput.addEventListener('change', () => {
            trainingFiles = Array.from(trainingFileInput.files);
            totalFileCount = trainingFiles.length;
            processedFileCount = 0; // カウンターをリセット
            processingStatusDiv.textContent = ''; // ステータスをクリア

            if (trainingFiles.length > 0) {
                trainingFileListDiv.style.display = 'block';
                trainingFileListDiv.innerHTML = ''; // リストをクリア

                trainingFiles.forEach((file, index) => {
                    const listItem = document.createElement('div');
                    listItem.classList.add('file-list-item');
                    listItem.innerHTML = `
                        <span>${file.name}</span>
                        <button class="remove-file" data-index="${index}">削除</button>
                    `;
                    trainingFileListDiv.appendChild(listItem);
                });

                // 削除ボタンのイベントリスナー
                trainingFileListDiv.querySelectorAll('.remove-file').forEach(button => {
                    button.addEventListener('click', (event) => {
                        const indexToRemove = parseInt(event.target.dataset.index);
                        trainingFiles.splice(indexToRemove, 1); // 配列から削除
                        totalFileCount = trainingFiles.length;
                        // リストを再描画
                        trainingFileListDiv.innerHTML = '';
                        trainingFiles.forEach((file, index) => {
                            const listItem = document.createElement('div');
                            listItem.classList.add('file-list-item');
                            listItem.innerHTML = `
                                <span>${file.name}</span>
                                <button class="remove-file" data-index="${index}">削除</button>
                            `;
                            trainingFileListDiv.appendChild(listItem);
                        });
                        if(trainingFiles.length === 0){
                            trainingFileListDiv.style.display = 'none';
                            processTrainingButton.disabled = true;
                        }
                    });
                });
              processTrainingButton.disabled = false;
            } else {
                trainingFileListDiv.style.display = 'none';
                processTrainingButton.disabled = true;
            }
        });

        // キャリブレーションデータの処理
        function processCalibrationData() {
          const file = calibrationFileInput.files[0];
          if (!file) {
            showAlert(calibrationResultDiv, 'ファイルを選択してください。', 'alert-warning');
            return;
          }

          Papa.parse(file, {
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            complete: function(results) {
              if (results.errors.length > 0) {
                results.errors.forEach(error => {
                    console.error('Parsing error:', error.code, error.message, error.row);
                    if (error.code === "TooFewFields" || error.code === "TooManyFields") {
                        showAlert(calibrationResultDiv, `CSVファイルの解析中にエラーが発生しました。行${error.row + 1}のカラム数が不正です。期待されるカラム数: ${calibrationExpectedColumns}`, 'alert-danger');
                    } else {
                        showAlert(calibrationResultDiv, 'CSVファイルの解析中にエラーが発生しました。', 'alert-danger');
                    }
                });
                return;
              }

              let fileCalibrationData = results.data;

              // 必要なカラムが存在するか確認
              const requiredColumns = ["Timestamp", "Power", ...muscleChannels];
              const missingColumns = requiredColumns.filter(col => !(col in fileCalibrationData[0]));

              if (missingColumns.length > 0) {
                showAlert(calibrationResultDiv, `必要なカラムがありません: ${missingColumns.join(', ')}`, 'alert-warning');
                return;
              }

              // 詳細なデータチェック
              const validData = fileCalibrationData.filter((row, rowIndex) => {
                const isValidRow = requiredColumns.every(col => {
                    if (row[col] === null || row[col] === undefined) {
                        console.error(`Row ${rowIndex + 2}: Column '${col}' is missing.`);
                        return false;
                    }
                    if (col !== "Timestamp") {
                      if(isNaN(row[col])){
                        console.error(`Row ${rowIndex + 2}: Column '${col}' is not a number.`);
                        return false
                      }
                    }
                    return true;
                });

                if (!isValidRow) {
                    showAlert(calibrationResultDiv, `CSVファイルの${rowIndex + 2}行目に不正なデータがあります。`, 'alert-warning');
                }
                return isValidRow;
              });

              calibrationData = validData;

              if (calibrationData.length === 0) {
                showAlert(calibrationResultDiv, '有効なデータがありません。', 'alert-warning');
                return;
              }

              muscleMeans = {};
              muscleChannels.forEach(ch => {
                const values = calibrationData.map(row => row[ch]);
                muscleMeans[ch] = values.reduce((sum, value) => sum + value, 0) / values.length;
              });

              // 結果の表示
              let resultHTML = '<h3>キャリブレーション結果</h3>';
              resultHTML += '<p>各チャネルの平均値（安静時）:</p>';
              resultHTML += '<table><tr><th>チャネル</th><th>平均値</th></tr>';
              muscleChannels.forEach(ch => {
                resultHTML += `<tr><td>${ch}</td><td>${muscleMeans[ch].toFixed(2)}</td></tr>`;
              });
              resultHTML += '</table>';

              showAlert(calibrationResultDiv, resultHTML, 'alert-success');
              // processTrainingButton.disabled = false; // ここでは有効化しない
            }
          });
        }

        // トレーニングデータの処理 (複数ファイル対応)
        function processTrainingData() {

            if (!muscleMeans || Object.keys(muscleMeans).length === 0) {
                showAlert(trainingResultDiv, 'キャリブレーションデータを先に処理してください。', 'alert-warning');
                return;
            }

            processedTrainingData = []; // 結果をリセット
            processedFileCount = 0; // カウントをリセット
            processingStatusDiv.textContent = `0 / ${totalFileCount} ファイル処理済み`;

            trainingFiles.forEach(file => {
                Papa.parse(file, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        if (results.errors.length > 0) {
                            showAlert(trainingResultDiv, `CSVファイルの解析中にエラーが発生しました。: ${results.errors[0].message}`, 'alert-danger');
                            console.error('Parsing errors:', results.errors);
                            return;
                        }

                        let fileTrainingData = results.data;

                        // 必要なカラムが存在するか確認
                        const requiredColumns = [...muscleChannels, ...angleColumns, ...positionColumns];
                        const missingColumns = requiredColumns.filter(col => !(col in fileTrainingData[0]));

                        if (missingColumns.length > 0) {
                            showAlert(trainingResultDiv, `必要なカラムがありません: ${missingColumns.join(', ')}`, 'alert-warning');
                            return;
                        }
                        // 詳細なデータチェック
                       const validData = fileTrainingData.filter((row, rowIndex) => {
                          const isValidRow = requiredColumns.every(col => {
                            if (row[col] === null || row[col] === undefined) {
                              console.error(`Row ${rowIndex + 2}: Column '${col}' is missing.`);
                              return false;
                          }
                            if(muscleChannels.includes(col) || angleColumns.includes(col) || positionColumns.includes(col)){
                                if (isNaN(row[col])) {
                                    console.error(`Row ${rowIndex + 2}: Column '${col}' is not a number.`);
                                    return false;
                                }
                            }

                            return true;
                        });

                        if (!isValidRow) {
                            showAlert(trainingResultDiv, `CSVファイルの${rowIndex + 2}行目に不正なデータがあります。`, 'alert-warning');
                        }
                        return isValidRow;
                    });

                        // 前処理
                        const fileProcessedTrainingData = validData.map(row => {
                            const processedRow = {...row};
                            muscleChannels.forEach(ch => {
                                processedRow[ch] = row[ch] - muscleMeans[ch];
                            });
                            return processedRow;
                        });

                        processedTrainingData = processedTrainingData.concat(fileProcessedTrainingData);

                        // 処理済みファイル数の更新と表示
                        processedFileCount++;
                        processingStatusDiv.textContent = `${processedFileCount} / ${totalFileCount} ファイル処理済み`;

                        if(processedFileCount === totalFileCount){
                            if (processedTrainingData.length > 0) {
                                const resultHTML = `
                                    <h3>トレーニングデータ前処理結果</h3>
                                    <p>処理されたデータポイント数: ${processedTrainingData.length}</p>
                                    <p>前処理方法: 各チャネルから安静時の平均値を引きました</p>
                                `;
                                showAlert(trainingResultDiv, resultHTML, 'alert-success');
                                buildModelButton.disabled = false;
                            }
                        }
                    },
                    error: function(error) {
                        console.error("Error:", error);
                        showAlert(trainingResultDiv, `CSVファイルの読み込み中にエラーが発生しました: ${error.message}`, 'alert-danger');
                    }
                });
            });
        }


        // モデル構築
        function buildNeuralNetworkModel() {
            if (!processedTrainingData || processedTrainingData.length === 0) {
                showAlert(modelResultDiv, 'トレーニングデータを先に処理してください。', 'alert-warning');
                return;
            }

            showAlert(modelResultDiv, 'モデルを構築中...', 'alert-info');
            loadingIndicator.style.display = 'block';
            modelProgressContainer.style.display = 'block';
            buildModelButton.disabled = true;

            // 入力（筋肉データ）と出力（角度データ）を準備
            const inputData = processedTrainingData.map(row => {
                // 筋肉データを配列として取得
                return muscleChannels.map(ch => parseFloat(row[ch]));
            });
            
            const outputData = processedTrainingData.map(row => {
                // 角度データを配列として取得
                return angleColumns.map(col => parseFloat(row[col]));
            });

            // モデルのオプションを設定
            const options = {
                task: 'regression',
                inputs: muscleChannels.length, // 入力の次元数（筋肉チャネル数）
                outputs: angleColumns.length,  // 出力の次元数（角度の種類）
                debug: true
            };

            // ニューラルネットワークを初期化
            neuralNetwork = ml5.neuralNetwork(options);

            console.log(`Adding ${inputData.length} training examples...`);
            
            // トレーニングデータを追加
            for (let i = 0; i < inputData.length; i++) {
                // 各データポイントをモデルに追加
                neuralNetwork.addData(inputData[i], outputData[i]);
            }

            // データの前処理（正規化）
            neuralNetwork.normalizeData();

            // トレーニングオプションを設定
            const trainingOptions = {
                epochs: parseInt(epochsInput.value),
                batchSize: parseInt(batchSizeInput.value),
                learningRate: 0.02
            };

            console.log("Starting model training with options:", trainingOptions);
            
            // トレーニング開始
            neuralNetwork.train(trainingOptions, whileTraining, finishedTraining);

            // トレーニング中の状態更新関数
            function whileTraining(epoch, loss) {
                console.log(`Epoch: ${epoch}, Loss: ${loss.loss}`);
                const progress = Math.round((epoch / trainingOptions.epochs) * 100);
                modelProgressBar.style.width = `${progress}%`;
                modelProgressBar.textContent = `${progress}%`;
                modelInfoDiv.innerHTML = `エポック: ${epoch}/${trainingOptions.epochs}, 損失: ${loss.loss.toFixed(4)}`;
            }

            // トレーニング完了時の関数
            function finishedTraining() {
                console.log("Model training completed successfully!");
                loadingIndicator.style.display = 'none';
                showAlert(modelResultDiv, 'モデルのトレーニングが完了しました！', 'alert-success');
                modelInfoDiv.innerHTML += '<br>モデルの構築が完了しました。テストデータを処理できます。';
                processTestButton.disabled = false;
                
                // トレーニングデータの一部で検証
                validateModel();
            }
            
            // モデルの検証関数（オプショナル）
            function validateModel() {
                // トレーニングデータからランダムにサンプルを選ぶ
                const validationSize = Math.min(5, processedTrainingData.length);
                const indices = [];
                for (let i = 0; i < validationSize; i++) {
                    const randomIndex = Math.floor(Math.random() * processedTrainingData.length);
                    indices.push(randomIndex);
                }
                
                console.log("Validating model with random samples");
                // 検証を実行
                let completed = 0;
                indices.forEach(idx => {
                    const input = muscleChannels.map(ch => processedTrainingData[idx][ch]);
                    const expected = angleColumns.map(col => processedTrainingData[idx][col]);
                    
                    neuralNetwork.predict(input, (error, results) => {
                        if (error) {
                            console.error("Validation prediction error:", error);
                            return;
                        }
                        
                        completed++;
                        console.log(`Validation sample ${completed}/${validationSize}:`);
                        console.log("Input:", input);
                        console.log("Expected:", expected);
                        console.log("Predicted:", results.map(r => r.value));
                        
                        if (completed === validationSize) {
                            console.log("Validation complete");
                        }
                    });
                });
            }
        }

        // テストデータの処理と予測
        function processTestData() {
            const file = testFileInput.files[0];
            if (!file) {
                showAlert(testResultDiv, 'ファイルを選択してください。', 'alert-warning');
                return;
            }

            if (!neuralNetwork) {
                showAlert(testResultDiv, 'モデルを先に構築してください。', 'alert-warning');
                return;
            }

            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        showAlert(testResultDiv, `CSVファイルの解析中にエラーが発生しました。: ${results.errors[0].message}`, 'alert-danger');
                        console.error('Parsing errors:', results.errors);
                        return;
                    }

                    let fileTestData = results.data;

                    // 必要なカラムが存在するか確認
                    const requiredColumns = ["Timestamp", "Power", ...muscleChannels];
                    const missingColumns = requiredColumns.filter(col => !(col in fileTestData[0]));
                    if (missingColumns.length > 0) {
                        showAlert(testResultDiv, `必要なカラムがありません: ${missingColumns.join(', ')}`, 'alert-warning');
                        return;
                    }

                    // 詳細なデータチェック
                    const validData = fileTestData.filter((row, rowIndex) => {
                        const isValidRow = requiredColumns.every(col => {
                            if (row[col] === null || row[col] === undefined) {
                                console.error(`Row ${rowIndex + 2}: Column '${col}' is missing.`);
                                return false;
                            }
                            if (col !== "Timestamp") {
                                if(isNaN(row[col])){
                                    console.error(`Row ${rowIndex + 2}: Column '${col}' is not a number.`);
                                    return false;
                                }
                            }
                            return true;
                        });

                        if (!isValidRow) {
                            showAlert(testResultDiv, `CSVファイルの${rowIndex + 2}行目に不正なデータがあります。`, 'alert-warning');
                        }
                        return isValidRow;
                    });

                    testData = validData;

                    if (testData.length === 0) {
                        showAlert(testResultDiv, '有効なデータがありません。', 'alert-warning');
                        return;
                    }

                    // 前処理
                    processedTestData = testData.map(row => {
                        const processedRow = {...row};
                        muscleChannels.forEach(ch => {
                            processedRow[ch] = row[ch] - muscleMeans[ch];  // キャリブレーションデータから計算した平均値を引く
                        });
                        return processedRow;
                    });

                    // モデルを使用して予測
                    showAlert(testResultDiv, '予測を実行中...', 'alert-info');
                    predictions = new Array(processedTestData.length);
                    let predictionsCompleted = 0;

                    // 各フレームごとに予測を行う
                    processedTestData.forEach((row, index) => {
                        const input = muscleChannels.map(ch => parseFloat(row[ch]));
                        
                        neuralNetwork.predict(input, (error, results) => {
                            if (error) {
                                console.error('予測エラー:', error);
                                return;
                            }
                            
                            // 予測結果を保存
                            predictions[index] = {
                                elbow_angle: results[0].value,
                                wrist_angle: results[1].value,
                                shoulder_angle: results[2].value
                            };

                            predictionsCompleted++;
                            
                            // すべての予測が完了したら処理
                            if (predictionsCompleted === processedTestData.length) {
                                console.log("All predictions completed:", predictions.length);
                                showAlert(testResultDiv, `${predictionsCompleted}フレームの腕の角度予測が完了しました。`, 'alert-success');
                                
                                // アニメーションの初期化
                                initializeAnimation();
                                visualizeData();
                                
                                // コントロールボタンの有効化
                                playAnimationButton.disabled = false;
                                pauseAnimationButton.disabled = true;
                                resetAnimationButton.disabled = false;
                            }
                        });
                    });
                },
                error: function(error) {
                    console.error("Error:", error);
                    showAlert(testResultDiv, `CSVファイルの読み込み中にエラーが発生しました: ${error.message}`, 'alert-danger');
                }
            });
        }

        // 以降、アニメーションと可視化の関数は変更なし
        function initializeAnimation() {
            // p5.jsのスケッチを作成
            new p5(function(p) {
                p.setup = function() {
                    const canvas = p.createCanvas(600, 400);
                    canvas.parent('animationContainer');
                    p.angleMode(p.DEGREES);
                    p.stroke(0);
                    p.strokeWeight(4);
                    p.noLoop();
                };

                p.draw = function() {
                    p.background(240);

                    if (predictions.length === 0 || currentFrame >= predictions.length) {
                        return;
                    }

                    const prediction = predictions[currentFrame];

                    // 角度情報を表示
                    angleInfoDiv.innerHTML = `
                        <p>フレーム: ${currentFrame + 1}/${predictions.length}</p>
                        <p>肘の角度: ${prediction.elbow_angle.toFixed(2)}°</p>
                        <p>手首の角度: ${prediction.wrist_angle.toFixed(2)}°</p>
                        <p>肩の角度: ${prediction.shoulder_angle.toFixed(2)}°</p>
                    `;

                    // 腕のアニメーション
                    const shoulderX = 150;
                    const shoulderY = 200;
                    const upperArmLength = 100;
                    const forearmLength = 100;
                    const handLength = 50;

                    // 肩の角度から上腕の位置を計算
                    const shoulderAngle = prediction.shoulder_angle;
                    const elbowX = shoulderX + p.cos(shoulderAngle) * upperArmLength;
                    const elbowY = shoulderY - p.sin(shoulderAngle) * upperArmLength;

                    // 肘の角度から前腕の位置を計算
                    const elbowAngle = prediction.elbow_angle;
                    const wristX = elbowX + p.cos(shoulderAngle - elbowAngle) * forearmLength;
                    const wristY = elbowY - p.sin(shoulderAngle - elbowAngle) * forearmLength;

                    // 手首の角度から手の位置を計算
                    const wristAngle = prediction.wrist_angle;
                    const handX = wristX + p.cos(shoulderAngle - elbowAngle - wristAngle) * handLength;
                    const handY = wristY - p.sin(shoulderAngle - elbowAngle - wristAngle) * handLength;

                    // 腕を描画
                    p.stroke(0);
                    p.strokeWeight(8);
                    p.line(shoulderX, shoulderY, elbowX, elbowY); // 上腕
                    p.stroke(60, 120, 216);
                    p.line(elbowX, elbowY, wristX, wristY); // 前腕
                    p.stroke(216, 60, 60);
                    p.line(wristX, wristY, handX, handY); // 手

                    // 関節を描画
                    p.fill(30);
                    p.noStroke();
                    p.ellipse(shoulderX, shoulderY, 15, 15); // 肩
                    p.ellipse(elbowX, elbowY, 12, 12); // 肘
                    p.ellipse(wristX, wristY, 10, 10); // 手首

                    // ダーツを描画
                    if (prediction.elbow_angle < 90) { // ダーツを投げる動作と判断
                        p.fill(0, 100, 0);
                        p.ellipse(handX, handY, 10, 10);

                        // ダーツの飛んでいく軌道を点線で表示
                        p.stroke(0, 100, 0, 150);
                        p.strokeWeight(1);
                        p.drawingContext.setLineDash([5, 5]);
                        const targetX = 500;
                        const targetY = 200;
                        p.line(handX, handY, targetX, targetY);
                        p.drawingContext.setLineDash([]);

                        // ダーツのターゲットを描画
                        p.noStroke();
                        p.fill(100, 0, 0);
                        p.ellipse(targetX, targetY, 40, 40);
                        p.fill(255);
                        p.ellipse(targetX, targetY, 25, 25);
                        p.fill(100, 0, 0);
                        p.ellipse(targetX, targetY, 10, 10);
                    }
                };

                p.updateWithData = function() {
                    if (predictions.length > 0) {
                        p.redraw();
                    }
                };

            }, 'animationContainer');
        }

        // アニメーションの再生
        function playAnimation() {
            if (isPlaying) return;

            isPlaying = true;
            playAnimationButton.disabled = true;
            pauseAnimationButton.disabled = false;

            function animate() {
                if (!isPlaying) return;

                if (currentFrame < predictions.length - 1) {
                    currentFrame++;
                    animationFrameId = setTimeout(animate, animationSpeed);
                } else {
                    // 最後のフレームで停止
                    isPlaying = false;
                    playAnimationButton.disabled = false;
                    pauseAnimationButton.disabled = true;
                }
                // p5.jsの描画関数を更新
                if (window.p5 && window.p5.prototype.updateWithData) {
                  window.p5.prototype.updateWithData();
                }
            }

            animate();
        }

        // アニメーションの一時停止
        function pauseAnimation() {
            isPlaying = false;
            playAnimationButton.disabled = false;
            pauseAnimationButton.disabled = true;
            clearTimeout(animationFrameId);
        }

        // アニメーションのリセット
        function resetAnimation() {
            isPlaying = false;
            currentFrame = 0;
            playAnimationButton.disabled = false;
            pauseAnimationButton.disabled = true;
            clearTimeout(animationFrameId);

            // p5.jsの描画関数を更新
             if (window.p5 && window.p5.prototype.updateWithData) {
                window.p5.prototype.updateWithData();
             }
            angleInfoDiv.innerHTML = ''; // 角度情報をクリア
        }
          // データ可視化 (Chart.jsを使用)

        function visualizeData() {
             if (!processedTestData || processedTestData.length === 0) {
                return;
            }
            // 筋変位データの可視化
            const muscleDataCtx = document.getElementById('muscleDataChart').getContext('2d');
             const muscleDataChart = new Chart(muscleDataCtx, {
                type: 'line',
                data: {
                    labels: processedTestData.map((_, index) => index + 1), // フレーム番号
                    datasets: muscleChannels.map(ch => ({
                        label: ch,
                        data: processedTestData.map(row => row[ch]),
                        borderColor: getRandomColor(),
                        fill: false,
                        borderWidth: 1,
                        pointRadius: 0
                    }))
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Frame'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Muscle Displacement'
                            }
                        }
                    }
                }
            });

           // 角度データの可視化
            const angleDataCtx = document.getElementById('angleDataChart').getContext('2d');
            const angleDataChart = new Chart(angleDataCtx, {
                type: 'line',
                data: {
                    labels: predictions.map((_, index) => index + 1),
                    datasets: angleColumns.map(col => ({
                        label: col,
                        data: predictions.map(p => p[col]),
                        borderColor: getRandomColor(),
                        fill: false,
                         borderWidth: 2,
                        pointRadius: 1
                    }))
                 },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                     scales: {
                        x: {
                             title: {
                                 display: true,
                                text: 'Frame'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Angle (degrees)'
                            }
                        }
                    }
                 }
             });
        }

        // ランダムな色を生成する関数
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }


        // アラートを表示する関数
        function showAlert(element, message, type) {
            element.innerHTML = message;
            element.className = `alert ${type}`;
            element.style.display = 'block';
        }

        // データ可視化の呼び出し (予測後)
        processTestButton.addEventListener('click', () => {
          // ... (他の処理)
          // 予測が完了した後に可視化関数を呼び出す
            const checkPredictionsInterval = setInterval(() => {
              if (predictions.length > 0 && predictions.length === processedTestData.length){
                visualizeData();
                clearInterval(checkPredictionsInterval);
              }
            }, 500); //500ミリ秒ごとに予測が完了しているか確認

        });
    </script>
</body>
</html>
