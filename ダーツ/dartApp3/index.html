<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ダーツ動作再現アプリ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ml5/0.12.2/ml5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border-left: 5px solid #3498db;
        }
        h2 {
            color: #3498db;
            margin-top: 0;
        }
        .file-input {
            margin-bottom: 15px;
        }
        .file-input label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .alert {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        .alert-info {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }
        .alert-success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .alert-warning {
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
        }
        .alert-danger {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            height: 400px;
            position: relative;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }
        .progress-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 4px;
            margin: 10px 0;
        }
        .progress-bar {
            height: 20px;
            background-color: #3498db;
            border-radius: 4px;
            width: 0;
            transition: width 0.3s;
            text-align: center;
            color: white;
            line-height: 20px;
        }
        #modelInfo {
            font-size: 14px;
            color: #666;
        }
        .chart-container {
            height: 200px;
            margin: 20px 0;
        }
        .visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        .visualization > div {
            flex: 1;
            min-width: 300px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        #loadingIndicator {
            display: none;
            text-align: center;
            margin: 10px 0;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #3498db;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ダーツ動作再現アプリ</h1>

        <div class="section">
            <h2>1. キャリブレーションデータのアップロード</h2>
            <p>安静時の筋変位データをアップロードしてください。</p>
            <div class="file-input">
                <label for="calibrationFile">キャリブレーションファイル:</label>
                <input type="file" id="calibrationFile" accept=".csv">
            </div>
            <button id="processCalibration">キャリブレーションデータを処理</button>
            <div id="calibrationResult" class="alert alert-info" style="display: none;"></div>
        </div>

        <div class="section">
            <h2>2. トレーニングデータのアップロード</h2>
            <p>筋変位データと腕の角度データを含むトレーニングファイルをアップロードしてください。</p>
            <div class="file-input">
                <label for="trainingFile">トレーニングファイル:</label>
                <input type="file" id="trainingFile" accept=".csv">
            </div>
            <button id="processTraining" disabled>トレーニングデータを処理</button>
            <div id="trainingResult" class="alert alert-info" style="display: none;"></div>
        </div>

        <div class="section">
            <h2>3. モデルの構築</h2>
            <p>前処理されたデータを使用してモデルを構築します。</p>
            <button id="buildModel" disabled>モデルを構築</button>
            <div id="loadingIndicator">
                <div class="spinner"></div>
                <p>モデル構築中...</p>
            </div>
            <div id="modelResult" class="alert alert-info" style="display: none;"></div>
            <div class="progress-container" id="modelProgressContainer" style="display: none;">
                <div class="progress-bar" id="modelProgressBar">0%</div>
            </div>
            <div id="modelInfo"></div>
        </div>

        <div class="section">
            <h2>4. テストデータのアップロード</h2>
            <p>予測したい筋変位データをアップロードしてください。</p>
            <div class="file-input">
                <label for="testFile">テストファイル:</label>
                <input type="file" id="testFile" accept=".csv">
            </div>
            <button id="processTest" disabled>テストデータを処理</button>
            <div id="testResult" class="alert alert-info" style="display: none;"></div>
        </div>

        <div class="section">
            <h2>5. 動きの再現</h2>
            <p>予測された腕の動きのアニメーション：</p>
            <div class="canvas-container" id="animationContainer"></div>
            <div class="controls">
                <button id="playAnimation" disabled>再生</button>
                <button id="pauseAnimation" disabled>一時停止</button>
                <button id="resetAnimation" disabled>リセット</button>
            </div>
            <div id="angleInfo"></div>
        </div>

        <div class="section">
            <h2>6. データ可視化</h2>
            <div class="visualization">
                <div>
                    <h3>筋変位データグラフ</h3>
                    <div class="chart-container" id="muscleDataChart"></div>
                </div>
                <div>
                    <h3>角度データグラフ</h3>
                    <div class="chart-container" id="angleDataChart"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // グローバル変数
        let calibrationData = null;
        let trainingData = null;
        let processedTrainingData = null;
        let testData = null;
        let processedTestData = null;
        let muscleMeans = {};
        let neuralNetwork = null;
        let predictions = [];
        let isPlaying = false;
        let currentFrame = 0;
        let animationFrameId = null;
        let animationSpeed = 50; // ミリ秒単位でのフレーム間の遅延
        //Chの数（今回は14）と、TimestampとPowerを合わせた16を指定
        let expectedColumns = 16;
        let muscleChannels = Array.from({length: 14}, (_, i) => `Ch.${i}`);
        let angleColumns = ['elbow_angle', 'wrist_angle', 'shoulder_angle'];
        let positionColumns = [
            'hand_x', 'hand_y', 'hand_z',
            'wrist_x', 'wrist_y', 'wrist_z',
            'elbow_x', 'elbow_y', 'elbow_z',
            'shoulder_x', 'shoulder_y', 'shoulder_z'
        ];

        // UI要素
        const calibrationFileInput = document.getElementById('calibrationFile');
        const processCalibrationButton = document.getElementById('processCalibration');
        const calibrationResultDiv = document.getElementById('calibrationResult');

        const trainingFileInput = document.getElementById('trainingFile');
        const processTrainingButton = document.getElementById('processTraining');
        const trainingResultDiv = document.getElementById('trainingResult');

        const buildModelButton = document.getElementById('buildModel');
        const modelResultDiv = document.getElementById('modelResult');
        const modelInfoDiv = document.getElementById('modelInfo');
        const modelProgressContainer = document.getElementById('modelProgressContainer');
        const modelProgressBar = document.getElementById('modelProgressBar');
        const loadingIndicator = document.getElementById('loadingIndicator');

        const testFileInput = document.getElementById('testFile');
        const processTestButton = document.getElementById('processTest');
        const testResultDiv = document.getElementById('testResult');

        const playAnimationButton = document.getElementById('playAnimation');
        const pauseAnimationButton = document.getElementById('pauseAnimation');
        const resetAnimationButton = document.getElementById('resetAnimation');
        const angleInfoDiv = document.getElementById('angleInfo');

        // イベントリスナー
        processCalibrationButton.addEventListener('click', processCalibrationData);
        processTrainingButton.addEventListener('click', processTrainingData);
        buildModelButton.addEventListener('click', buildNeuralNetworkModel);
        processTestButton.addEventListener('click', processTestData);
        playAnimationButton.addEventListener('click', playAnimation);
        pauseAnimationButton.addEventListener('click', pauseAnimation);
        resetAnimationButton.addEventListener('click', resetAnimation);

// キャリブレーションデータの処理
function processCalibrationData() {
    const file = calibrationFileInput.files[0];
    if (!file) {
        showAlert(calibrationResultDiv, 'ファイルを選択してください。', 'alert-warning');
        return;
    }

    Papa.parse(file, {
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true, // 空行をスキップ
        complete: function(results) {
            if (results.errors.length > 0) {
                // エラーの種類をより詳細に確認
                results.errors.forEach(error => {
                    console.error('Parsing error:', error.code, error.message, error.row);
                    if (error.code === "TooFewFields" || error.code === "TooManyFields") {
                        showAlert(calibrationResultDiv, `CSVファイルの解析中にエラーが発生しました。行${error.row}のカラム数が不正です。期待されるカラム数: ${expectedColumns}`, 'alert-danger');
                    } else {
                        showAlert(calibrationResultDiv, 'CSVファイルの解析中にエラーが発生しました。', 'alert-danger');
                    }
                });
                return;
            }


            calibrationData = results.data;
          // データの最初の行からカラム数をチェック
            if (calibrationData.length > 0) {
                const firstRow = calibrationData[0];
                const actualColumns = Object.keys(firstRow).filter(key => firstRow[key] !== null && firstRow[key] !== undefined).length;

                if (actualColumns !== expectedColumns) {
                    showAlert(calibrationResultDiv, `CSVファイルのカラム数が不正です。期待されるカラム数: ${expectedColumns}, 実際のカラム数: ${actualColumns}`, 'alert-danger');
                    calibrationData = null; // データをクリア
                    return;
                }
            }

            // 欠損値や無効なデータを除外
            calibrationData = calibrationData.filter(row => {
              return muscleChannels.every(ch => row[ch] !== null && row[ch] !== undefined && !isNaN(row[ch]));

            });

            if (calibrationData.length === 0) {
                showAlert(calibrationResultDiv, '有効なデータがありません。', 'alert-warning');
                return;
            }

            // 各チャネルの平均値を計算
            muscleMeans = {};
            muscleChannels.forEach(ch => {
                const values = calibrationData.map(row => row[ch]);
                muscleMeans[ch] = values.reduce((sum, value) => sum + value, 0) / values.length;
            });

            // 結果の表示
            let resultHTML = '<h3>キャリブレーション結果</h3>';
            resultHTML += '<p>各チャネルの平均値（安静時）:</p>';
            resultHTML += '<table><tr><th>チャネル</th><th>平均値</th></tr>';
            muscleChannels.forEach(ch => {
                resultHTML += `<tr><td>${ch}</td><td>${muscleMeans[ch].toFixed(2)}</td></tr>`;
            });
            resultHTML += '</table>';

            showAlert(calibrationResultDiv, resultHTML, 'alert-success');

            // トレーニングデータ処理ボタンを有効化
            processTrainingButton.disabled = false;
        }
    });
}
        // トレーニングデータの処理（ここは以前と変わらず）
        function processTrainingData() {
            const file = trainingFileInput.files[0];
            if (!file) {
                showAlert(trainingResultDiv, 'ファイルを選択してください。', 'alert-warning');
                return;
            }

            if (!muscleMeans || Object.keys(muscleMeans).length === 0) {
                showAlert(trainingResultDiv, 'キャリブレーションデータを先に処理してください。', 'alert-warning');
                return;
            }

            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        showAlert(trainingResultDiv, 'CSVファイルの解析中にエラーが発生しました。', 'alert-danger');
                        console.error('Parsing errors:', results.errors);
                        return;
                    }

                    trainingData = results.data;

                    // 必要なカラムが存在するか確認
                    const requiredColumns = [...muscleChannels, ...angleColumns, ...positionColumns];
                    const missingColumns = requiredColumns.filter(col => !(col in trainingData[0]));

                    if (missingColumns.length > 0) {
                        showAlert(trainingResultDiv, `必要なカラムがありません: ${missingColumns.join(', ')}`, 'alert-warning');
                        return;
                    }

                    // 前処理：安静時の平均値を引く
                    processedTrainingData = trainingData.map(row => {
                        const processedRow = {...row};
                        muscleChannels.forEach(ch => {
                            if (row[ch] !== null && row[ch] !== undefined && !isNaN(row[ch])) {
                                processedRow[ch] = row[ch] - muscleMeans[ch];
                            } else {
                                processedRow[ch] = 0;
                            }
                        });
                        return processedRow;
                    });

                    // 欠損値や無効なデータを除外
                    processedTrainingData = processedTrainingData.filter(row => {
                        return muscleChannels.every(ch => row[ch] !== null && !isNaN(row[ch])) &&
                               angleColumns.every(col => row[col] !== null && !isNaN(row[col])) &&
                               positionColumns.every(col => row[col] !== null && !isNaN(row[col]));
                    });

                    if (processedTrainingData.length === 0) {
                        showAlert(trainingResultDiv, '有効なデータがありません。', 'alert-warning');
                        return;
                    }

                    // 結果の表示
                    const resultHTML = `
                        <h3>トレーニングデータ前処理結果</h3>
                        <p>処理されたデータポイント数: ${processedTrainingData.length}</p>
                        <p>前処理方法: 各チャネルから安静時の平均値を引きました</p>
                    `;

                    showAlert(trainingResultDiv, resultHTML, 'alert-success');

                    // モデル構築ボタンを有効化
                    buildModelButton.disabled = false;
                }
            });
        }

        // ニューラルネットワークモデルの構築、テストデータの処理、アニメーション、可視化の関数は変更なし
        function buildNeuralNetworkModel() {
            if (!processedTrainingData || processedTrainingData.length === 0) {
                showAlert(modelResultDiv, 'トレーニングデータを先に処理してください。', 'alert-warning');
                return;
            }

            // モデル構築開始表示
            showAlert(modelResultDiv, 'モデルを構築中...', 'alert-info');
            loadingIndicator.style.display = 'block';
            modelProgressContainer.style.display = 'block';
            buildModelButton.disabled = true;

            // 入力と出力データの準備
            const inputData = processedTrainingData.map(row => muscleChannels.map(ch => row[ch]));
            const outputData = processedTrainingData.map(row => angleColumns.map(col => row[col]));

            // ニューラルネットワークの設定
            const options = {
                task: 'regression',
                layers: [
                    {
                        type: 'dense',
                        units: 32,
                        activation: 'relu'
                    },
                    {
                        type: 'dense',
                        units: 16,
                        activation: 'relu'
                    }
                ],
                debug: true
            };

            neuralNetwork = ml5.neuralNetwork(options);

            // データを追加
            for (let i = 0; i < inputData.length; i++) {
                neuralNetwork.addData(inputData[i], outputData[i]);
            }

            // データの正規化
            neuralNetwork.normalizeData();

            // モデルのトレーニング
            const trainingOptions = {
                epochs: 50,
                batchSize: 32
            };

            neuralNetwork.train(trainingOptions, whileTraining, finishedTraining);

            function whileTraining(epoch, loss) {
                console.log(`Epoch: ${epoch}, Loss: ${loss.loss}`);
                const progress = Math.round((epoch / trainingOptions.epochs) * 100);
                modelProgressBar.style.width = `${progress}%`;
                modelProgressBar.textContent = `${progress}%`;
                modelInfoDiv.innerHTML = `エポック: ${epoch}/${trainingOptions.epochs}, 損失: ${loss.loss.toFixed(4)}`;
            }

            function finishedTraining() {
                loadingIndicator.style.display = 'none';
                showAlert(modelResultDiv, 'モデルのトレーニングが完了しました！', 'alert-success');
                modelInfoDiv.innerHTML += '<br>モデルの構築が完了しました。テストデータを処理できます。';

                // テストデータ処理ボタンを有効化
                processTestButton.disabled = false;
            }
        }

        // テストデータの処理
        function processTestData() {
            const file = testFileInput.files[0];
            if (!file) {
                showAlert(testResultDiv, 'ファイルを選択してください。', 'alert-warning');
                return;
            }

            if (!neuralNetwork) {
                showAlert(testResultDiv, 'モデルを先に構築してください。', 'alert-warning');
                return;
            }

            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        showAlert(testResultDiv, 'CSVファイルの解析中にエラーが発生しました。', 'alert-danger');
                        console.error('Parsing errors:', results.errors);
                        return;
                    }

                    testData = results.data;

                    // 必要なカラムが存在するか確認
                    const hasMuscleChannels = muscleChannels.every(ch => ch in testData[0]);

                    if (!hasMuscleChannels) {
                        showAlert(testResultDiv, '筋変位データのカラムがありません。', 'alert-warning');
                        return;
                    }

                    // 前処理：安静時の平均値を引く
                    processedTestData = testData.map(row => {
                        const processedRow = {...row};
                        muscleChannels.forEach(ch => {
                            if (row[ch] !== null && row[ch] !== undefined && !isNaN(row[ch])) {
                                processedRow[ch] = row[ch] - muscleMeans[ch];
                            } else {
                                processedRow[ch] = 0;
                            }
                        });
                        return processedRow;
                    });

                    // 欠損値や無効なデータを除外
                    processedTestData = processedTestData.filter(row => {
                        return muscleChannels.every(ch => row[ch] !== null && !isNaN(row[ch]));
                    });

                    if (processedTestData.length === 0) {
                        showAlert(testResultDiv, '有効なデータがありません。', 'alert-warning');
                        return;
                    }

                    // モデルを使用して予測
                    predictions = [];
                    let predictionsCompleted = 0;

                    processedTestData.forEach((row, index) => {
                        const input = muscleChannels.map(ch => row[ch]);
                        neuralNetwork.predict(input, (error, results) => {
                            if (error) {
                                console.error('予測エラー:', error);
                                return;
                            }

                            predictions[index] = {
                                elbow_angle: results[0].value,
                                wrist_angle: results[1].value,
                                shoulder_angle: results[2].value
                            };

                            predictionsCompleted++;

                            if (predictionsCompleted === processedTestData.length) {
                                // 予測が完了
                                showAlert(testResultDiv, `${predictionsCompleted}フレームの腕の角度予測が完了しました。`, 'alert-success');

                                // アニメーションの初期化
                                initializeAnimation();

                                // アニメーションコントロールを有効化
                                playAnimationButton.disabled = false;
                                resetAnimationButton.disabled = false;
                            }
                        });
                    });
                }
            });
        }

        // アニメーションの初期化
        function initializeAnimation() {
            // p5.jsのスケッチを作成
            new p5(function(p) {
                p.setup = function() {
                    const canvas = p.createCanvas(600, 400);
                    canvas.parent('animationContainer');
                    p.angleMode(p.DEGREES);
                    p.stroke(0);
                    p.strokeWeight(4);
                    p.noLoop();
                };

                p.draw = function() {
                    p.background(240);

                    if (predictions.length === 0 || currentFrame >= predictions.length) {
                        return;
                    }

                    const prediction = predictions[currentFrame];

                    // 角度情報を表示
                    angleInfoDiv.innerHTML = `
                        <p>フレーム: ${currentFrame + 1}/${predictions.length}</p>
                        <p>肘の角度: ${prediction.elbow_angle.toFixed(2)}°</p>
                        <p>手首の角度: ${prediction.wrist_angle.toFixed(2)}°</p>
                        <p>肩の角度: ${prediction.shoulder_angle.toFixed(2)}°</p>
                    `;

                    // 腕のアニメーション
                    const shoulderX = 150;
                    const shoulderY = 200;
                    const upperArmLength = 100;
                    const forearmLength = 100;
                    const handLength = 50;

                    // 肩の角度から上腕の位置を計算
                    const shoulderAngle = prediction.shoulder_angle;
                    const elbowX = shoulderX + p.cos(shoulderAngle) * upperArmLength;
                    const elbowY = shoulderY - p.sin(shoulderAngle) * upperArmLength;

                    // 肘の角度から前腕の位置を計算
                    const elbowAngle = prediction.elbow_angle;
                    const wristX = elbowX + p.cos(shoulderAngle - elbowAngle) * forearmLength;
                    const wristY = elbowY - p.sin(shoulderAngle - elbowAngle) * forearmLength;

                    // 手首の角度から手の位置を計算
                    const wristAngle = prediction.wrist_angle;
                    const handX = wristX + p.cos(shoulderAngle - elbowAngle - wristAngle) * handLength;
                    const handY = wristY - p.sin(shoulderAngle - elbowAngle - wristAngle) * handLength;

                    // 腕を描画
                    p.stroke(0);
                    p.strokeWeight(8);
                    p.line(shoulderX, shoulderY, elbowX, elbowY); // 上腕
                    p.stroke(60, 120, 216);
                    p.line(elbowX, elbowY, wristX, wristY); // 前腕
                    p.stroke(216, 60, 60);
                    p.line(wristX, wristY, handX, handY); // 手

                    // 関節を描画
                    p.fill(30);
                    p.noStroke();
                    p.ellipse(shoulderX, shoulderY, 15, 15); // 肩
                    p.ellipse(elbowX, elbowY, 12, 12); // 肘
                    p.ellipse(wristX, wristY, 10, 10); // 手首

                    // ダーツを描画
                    if (prediction.elbow_angle < 90) { // ダーツを投げる動作と判断
                        p.fill(0, 100, 0);
                        p.ellipse(handX, handY, 10, 10);

                        // ダーツの飛んでいく軌道を点線で表示
                        p.stroke(0, 100, 0, 150);
                        p.strokeWeight(1);
                        p.drawingContext.setLineDash([5, 5]);
                        const targetX = 500;
                        const targetY = 200;
                        p.line(handX, handY, targetX, targetY);
                        p.drawingContext.setLineDash([]);

                        // ダーツのターゲットを描画
                        p.noStroke();
                        p.fill(100, 0, 0);
                        p.ellipse(targetX, targetY, 40, 40);
                        p.fill(255);
                        p.ellipse(targetX, targetY, 25, 25);
                        p.fill(100, 0, 0);
                        p.ellipse(targetX, targetY, 10, 10);
                    }
                };

                p.updateWithData = function() {
                    if (predictions.length > 0) {
                        p.redraw();
                    }
                };

            }, 'animationContainer');
        }

        // アニメーションの再生
        function playAnimation() {
            if (isPlaying) return;

            isPlaying = true;
            playAnimationButton.disabled = true;
            pauseAnimationButton.disabled = false;

            function animate() {
                if (!isPlaying) return;

                if (currentFrame < predictions.length - 1) {
                    currentFrame++;
                    animationFrameId = setTimeout(animate, animationSpeed);
                } else {
                    // 最後のフレームで停止
                    isPlaying = false;
                    playAnimationButton.disabled = false;
                    pauseAnimationButton.disabled = true;
                }
                // p5.jsの描画関数を更新
                if (window.p5 && window.p5.prototype.updateWithData) {
                  window.p5.prototype.updateWithData();
                }
            }

            animate();
        }

        // アニメーションの一時停止
        function pauseAnimation() {
            isPlaying = false;
            playAnimationButton.disabled = false;
            pauseAnimationButton.disabled = true;
            clearTimeout(animationFrameId);
        }

        // アニメーションのリセット
        function resetAnimation() {
            isPlaying = false;
            currentFrame = 0;
            playAnimationButton.disabled = false;
            pauseAnimationButton.disabled = true;
            clearTimeout(animationFrameId);

            // p5.jsの描画関数を更新
             if (window.p5 && window.p5.prototype.updateWithData) {
                window.p5.prototype.updateWithData();
             }
            angleInfoDiv.innerHTML = ''; // 角度情報をクリア
        }
          // データ可視化 (Chart.jsを使用)

        function visualizeData() {
             if (!processedTestData || processedTestData.length === 0) {
                return;
            }
            // 筋変位データの可視化
            const muscleDataCtx = document.getElementById('muscleDataChart').getContext('2d');
             const muscleDataChart = new Chart(muscleDataCtx, {
                type: 'line',
                data: {
                    labels: processedTestData.map((_, index) => index + 1), // フレーム番号
                    datasets: muscleChannels.map(ch => ({
                        label: ch,
                        data: processedTestData.map(row => row[ch]),
                        borderColor: getRandomColor(),
                        fill: false,
                        borderWidth: 1,
                        pointRadius: 0
                    }))
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Frame'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Muscle Displacement'
                            }
                        }
                    }
                }
            });

           // 角度データの可視化
            const angleDataCtx = document.getElementById('angleDataChart').getContext('2d');
            const angleDataChart = new Chart(angleDataCtx, {
                type: 'line',
                data: {
                    labels: predictions.map((_, index) => index + 1),
                    datasets: angleColumns.map(col => ({
                        label: col,
                        data: predictions.map(p => p[col]),
                        borderColor: getRandomColor(),
                        fill: false,
                         borderWidth: 2,
                        pointRadius: 1
                    }))
                 },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                     scales: {
                        x: {
                             title: {
                                 display: true,
                                text: 'Frame'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Angle (degrees)'
                            }
                        }
                    }
                 }
             });
        }

        // ランダムな色を生成する関数
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }


        // アラートを表示する関数
        function showAlert(element, message, type) {
            element.innerHTML = message;
            element.className = `alert ${type}`;
            element.style.display = 'block';
        }

        // データ可視化の呼び出し (予測後)
        processTestButton.addEventListener('click', () => {
          // ... (他の処理)
          // 予測が完了した後に可視化関数を呼び出す
            const checkPredictionsInterval = setInterval(() => {
              if (predictions.length > 0 && predictions.length === processedTestData.length){
                visualizeData();
                clearInterval(checkPredictionsInterval);
              }
            }, 500); //500ミリ秒ごとに予測が完了しているか確認

        });

    </script>

</body>
</html>

